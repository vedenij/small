# Implementation Plan: Governance-Controlled TrainingAllowList

This plan describes, step-by-step, how to implement a governance-controlled TrainingAllowList so that only approved SDK addresses can send training-related messages. It is THE plan to follow.

IMPORTANT: Do not edit any `.pb.go` files directly. Modify `.proto` files and run code generation from `inference-chain` using Ignite. All state must remain deterministic; do not iterate over Go maps for state.

## Architecture Overview

- Module: `inference` (existing)
- New state: TrainingAllowList as a collections.KeySet of sdk.AccAddress (NOT an Ignite map). Name exactly: TrainingAllowList.
  - Keeper field: `TrainingAllowList collections.KeySet[sdk.AccAddress]` initialized with `sdk.AccAddressKey` and `types.TrainingAllowListPrefix`.
  - Deterministic: collections iteration order is by key; still sort outputs when returning lists.
- Governance-only messages (routed via gov):
  - `MsgAddUserToTrainingAllowList`
  - `MsgRemoveUserFromTrainingAllowList`
  - `MsgSetTrainingAllowList`
- Enforcement: All training-related Msg handlers must check TrainingAllowList.Has(ctx, creatorAccAddr) before proceeding. No helper wrappers; use the KeySet directly.

## Preliminaries

- Work in directory: `inference-chain`
- Regenerate protobufs after editing protos: `ignite generate proto-go`
- Run unit tests after each step: `go test ./...`

## Step-by-Step Tasks

1. Ensure TrainingAllowList KeySet exists in Keeper (collections)
   - Files to inspect/modify:
     - `x/inference/types/keys.go`: must define `TrainingAllowListPrefix = collections.NewPrefix(<unique id>)`.
     - `x/inference/keeper/keeper.go`: must include the field `TrainingAllowList collections.KeySet[sdk.AccAddress]` and initialize it via `collections.NewKeySet(sb, types.TrainingAllowListPrefix, "training_allow_list", sdk.AccAddressKey)`.
   - Code required (keeper.go initialization snippet):
     - `TrainingAllowList: collections.NewKeySet(sb, types.TrainingAllowListPrefix, "training_allow_list", sdk.AccAddressKey),`
   - Unit tests (run now):
     - Command: `cd inference-chain && go test ./...`
     - Purpose: verify project compiles and existing tests still pass with the KeySet declared (or already present). If it fails, fix compilation before proceeding.

2. Create governance messages with Ignite (NO manual proto edits)
   - Run from `inference-chain/`:
     - `ignite scaffold message addUserToTrainingAllowList authority address --module inference`
     - `ignite scaffold message removeUserFromTrainingAllowList authority address --module inference`
     - `ignite scaffold message setTrainingAllowList authority addresses:strings --module inference`
   - Ignite will update proto files and generate stubs automatically (Msg service, types, and msg server skeletons). Do not edit tx.proto by hand.
   - Generate code: `ignite generate proto-go`.
   - Unit tests (run now): `go test ./...` to ensure generated code compiles.

3. Msg server handler: AddUserToTrainingAllowList (authority-gated)
   - Files: implement handler in the generated file under `x/inference/keeper/` (method on `msgServer`).
   - Implementation requirements:
     - Authority check: compare `msg.Authority` to `k.authority`; if mismatch, return `types.ErrInvalidSigner` (use existing pattern from `MsgUpdateParams`).
     - Parse and validate bech32: `addr, err := sdk.AccAddressFromBech32(msg.Address)`; error if invalid.
     - Update KeySet directly: `if err := k.TrainingAllowList.Set(ctx, addr); err != nil { return nil, err }`.
     - Return empty response struct generated by Ignite.
   - Unit tests to create and run:
     - File: `x/inference/keeper/msg_training_allowlist_add_test.go`
     - Cases: unauthorized authority fails; invalid bech32 fails; valid request adds address and `Has(ctx, addr)` returns true.
     - Run: `go test ./...`.

4. Msg server handler: RemoveUserFromTrainingAllowList (authority-gated)
   - Implementation requirements:
     - Authority check as above.
     - Parse bech32 address.
     - Remove from KeySet: `if err := k.TrainingAllowList.Remove(ctx, addr); err != nil { return nil, err }`.
   - Unit tests:
     - File: `x/inference/keeper/msg_training_allowlist_remove_test.go`
     - Cases: unauthorized fails; removing non-existent is ok (idempotent) or verify `Has` becomes false after prior add; invalid bech32 fails.
     - Run: `go test ./...`.

5. Msg server handler: SetTrainingAllowList (authority-gated, replace all)
   - Implementation requirements:
     - Authority check as above.
     - Parse all `addresses` to `[]sdk.AccAddress`, error on any invalid.
     - Clear KeySet: iterate with `k.TrainingAllowList.Walk(ctx, nil, func(a sdk.AccAddress) (bool, error) { return false, k.TrainingAllowList.Remove(ctx, a) })`.
     - Re-add new addresses (deduplicate deterministically):
       - Convert to string slice; sort; unique; then Set each address.
   - Unit tests:
     - File: `x/inference/keeper/msg_training_allowlist_set_test.go`
     - Cases: unauthorized fails; invalid bech32 fails; setting a list replaces prior contents; duplicates handled; final set equals input (order-independent).
     - Run: `go test ./...`.

6. Gate ALL training messages on TrainingAllowList (no helpers; use KeySet directly)
   - Messages to gate (current tx.proto training-related):
     - `MsgCreateTrainingTask`
     - `MsgCreateDummyTrainingTask`
     - `MsgJoinTraining`
     - `MsgJoinTrainingStatus`
     - `MsgTrainingHeartbeat`
     - `MsgSetBarrier`
     - `MsgClaimTrainingTaskForAssignment`
     - `MsgAssignTrainingTask`
     - `MsgSubmitTrainingKvRecord`
   - Enforcement pattern to add at the top of each handler:
     - `creator, err := sdk.AccAddressFromBech32(msg.Creator); if err != nil { return nil, err }`
     - `ok, err := k.TrainingAllowList.Has(ctx, creator); if err != nil || !ok { return nil, types.ErrTrainingNotAllowed }`
   - Unit tests for each handler (create/augment respective _test.go):
     - For each message above, add two tests:
       - Sender not on allow list -> expect `types.ErrTrainingNotAllowed`.
       - Sender on allow list (pre-populate via KeySet.Set in test) -> handler proceeds minimal happy path.
     - Run: `go test ./...`.

7. Add gRPC query for current TrainingAllowList (use Ignite to scaffold)
   - Run from `inference-chain/`:
     - `ignite scaffold query trainingAllowList --module inference --response addresses:strings`
   - This will update `query.proto`, generate request/response types, and keeper/query stubs.
   - Implement keeper query at `x/inference/keeper/grpc_query_training_allow_list.go`:
     - Walk the KeySet, collect addresses to []string, sort lexicographically, return in response.
   - Generate code: `ignite generate proto-go`.
   - Unit tests:
     - File: `x/inference/keeper/grpc_query_training_allow_list_test.go`
     - Cases: empty set returns empty list; non-empty returns sorted addresses.
     - Run: `go test ./...`.

8. Wire CLI via AutoCLI (query only; no Tx commands)
   - File to modify: `x/inference/module/autocli.go`.
   - Register ONLY the TrainingAllowList query under the moduleâ€™s Query service. Do NOT expose any governance Msg RPCs as CLI Tx commands.
     - Query command: `inferenced q inference training-allow-list` -> calls `Query.TrainingAllowList`.
   - Concretely, extend `AutoCLIOptions()` to include ONLY:
     - `Query: { Service: modulev1.Query_ServiceDesc.ServiceName, RpcCommandOptions: [...] }` entry for `TrainingAllowList` with no request fields. Do not add any `Tx` RpcCommandOptions for Msg service.
   - Unit tests:
     - If CLI e2e patterns exist in module tests, add minimal assertions for the query command registration. Otherwise, rely on the gRPC query tests and manual verification with `inferenced q inference --help` during dev.
   - Run: `go test ./...`.

## Acceptance Criteria Checklist
- TrainingAllowList exists as a collections.KeySet and is used directly in code (no helper wrappers).
- Three governance messages exist, are authority-gated, and pass unit tests per handler.
- All listed training message handlers enforce the allow list; unit tests verify both rejection and acceptance cases.
- Query returns the current allow list deterministically (sorted) and has unit tests.
- CLI query exists and functions using the gRPC query.
- No Tx CLI commands are added for governance messages.
- Protos compile after changes: `ignite generate proto-go` passes; unit tests: `go test ./...` pass after each step.
