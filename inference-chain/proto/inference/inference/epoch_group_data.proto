syntax = "proto3";
import "inference/inference/participant.proto";
import "inference/inference/params.proto";
import "inference/inference/model.proto";
package inference.inference;

option go_package = "github.com/productscience/inference/x/inference/types";

// Enum for timeslot types
enum TimeslotType {
  PRE_POC_SLOT = 0;
  POC_SLOT = 1;
}

// These top two values are uint64s because they are IDs, not numerical values.
message EpochGroupData {
  uint64 poc_start_block_height = 1;
  uint64 epoch_group_id = 2;
  string epoch_policy = 3;
  int64 effective_block_height = 4;
  int64 last_block_height = 5;
  repeated SeedSignature member_seed_signatures = 6;
  repeated ValidationWeight validation_weights = 8;
  int64 unit_of_compute_price = 9;
  int64 number_of_requests = 10;
  int64 previous_epoch_requests = 11;
  ValidationParams validation_params = 12;
  int64 total_weight = 13;
  // If model_id is empty, this is the parent EpochGroup
  // If model_id is set, this is a sub EpochGroup for that specific model
  string model_id = 14;
  // List of model IDs for sub EpochGroups, only used in parent EpochGroup
  repeated string sub_group_models = 15;
  uint64 epoch_index = 16;
  Model model_snapshot = 17;
  int64 total_throughput = 18;
}

message ValidationWeight {
  string member_address = 1;
  int64 weight = 2;
  int32 reputation = 3;
  // We may decide to move ml_nodes directly to EpochGroupData,
  // but for now, this is a good solution.
  repeated MLNodeInfo ml_nodes = 4;
}

message SeedSignature {
  string member_address = 1;
  string signature = 2;
}

message MLNodeInfo {
  string node_id = 1;
  int64 throughput = 2;
  int64 poc_weight = 3;
  repeated bool timeslot_allocation = 4;
}
